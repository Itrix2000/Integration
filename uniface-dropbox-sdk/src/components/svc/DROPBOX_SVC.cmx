<?xml version='1.0' encoding='UTF-8' ?>
<!-- Created by Uniface - (C) Uniface B.V. All rights reserved -->
<!DOCTYPE UNIFACE PUBLIC "UNIFACE.DTD" "UNIFACE.DTD">
<UNIFACE release="9.6" xmlengine="2.0">
<TABLE>
<DSC name="UFORM" model="DICT" system="S" pseudo ="73" level="1" noupdate="0"
 rbk="0" ffsql="0" transnr="0" segsize="0" ufocc="1000" charset=".U">
<FLD name="UTIMESTAMP" seqno="1" type="E" level="2" pack="0" scale="0" length="15"
 pointer="0" inum="0" ufocc="0" />
<FLD name="UCOMPSTAMP" seqno="2" type="E" level="2" pack="0" scale="0" length="15"
 pointer="0" inum="0" ufocc="0" />
<FLD name="ULABEL" seqno="3" type="S" level="2" pack="0" scale="0" length="16"
 pointer="0" inum="1" ufocc="0" mandatory="yes" idxnum="1" idxsnr="101" />
<FLD name="FTYP" seqno="4" type="S" level="2" pack="0" scale="0" length="4"
 pointer="0" inum="0" ufocc="0" />
<FLD name="UVERS" seqno="5" type="S" level="2" pack="0" scale="0" length="12"
 pointer="0" inum="0" ufocc="0" />
<FLD name="UDESCR" seqno="6" type="S" level="2" pack="0" scale="0" length="25"
 pointer="0" inum="0" ufocc="0" />
<FLD name="FHEAD" seqno="7" type="S" level="2" pack="0" scale="0" length="6"
 pointer="0" inum="0" ufocc="0" />
<FLD name="VMAAT" seqno="8" type="S" level="2" pack="0" scale="0" length="6"
 pointer="0" inum="0" ufocc="0" />
<FLD name="HMAAT" seqno="9" type="S" level="2" pack="0" scale="0" length="6"
 pointer="0" inum="0" ufocc="0" />
<FLD name="UCOLOR" seqno="10" type="S" level="2" pack="0" scale="0" length="6"
 pointer="0" inum="0" ufocc="0" />
<FLD name="WVPOS" seqno="11" type="S" level="2" pack="0" scale="0" length="6"
 pointer="0" inum="0" ufocc="0" />
<FLD name="WHPOS" seqno="12" type="S" level="2" pack="0" scale="0" length="6"
 pointer="0" inum="0" ufocc="0" />
<FLD name="WVSIZ" seqno="13" type="S" level="2" pack="0" scale="0" length="6"
 pointer="0" inum="0" ufocc="0" />
<FLD name="WHSIZ" seqno="14" type="S" level="2" pack="0" scale="0" length="6"
 pointer="0" inum="0" ufocc="0" />
<FLD name="CLRSCRN" seqno="15" type="S" level="2" pack="0" scale="0" length="1"
 pointer="0" inum="0" ufocc="0" />
<FLD name="UBORDER" seqno="16" type="S" level="2" pack="0" scale="0" length="1"
 pointer="0" inum="0" ufocc="0" />
<FLD name="RIBIN" seqno="17" type="S" level="2" pack="0" scale="0" length="16"
 pointer="0" inum="0" ufocc="0" />
<FLD name="RIBOT" seqno="18" type="S" level="2" pack="0" scale="0" length="16"
 pointer="0" inum="0" ufocc="0" />
<FLD name="MOVABLE" seqno="19" type="S" level="2" pack="0" scale="0" length="1"
 pointer="0" inum="0" ufocc="0" />
<FLD name="VIDEOINVERSE" seqno="20" type="S" level="2" pack="0" scale="0" length="1"
 pointer="0" inum="0" ufocc="0" />
<FLD name="VIDEOBRIGHT" seqno="21" type="S" level="2" pack="0" scale="0" length="1"
 pointer="0" inum="0" ufocc="0" />
<FLD name="VIDEOUNLINE" seqno="22" type="S" level="2" pack="0" scale="0" length="1"
 pointer="0" inum="0" ufocc="0" />
<FLD name="VIDEOBLINK" seqno="23" type="S" level="2" pack="0" scale="0" length="1"
 pointer="0" inum="0" ufocc="0" />
<FLD name="UPANEL" seqno="24" type="S" level="2" pack="0" scale="0" length="16"
 pointer="0" inum="0" ufocc="0" />
<FLD name="POSPANEL" seqno="25" type="S" level="2" pack="0" scale="0" length="1"
 pointer="0" inum="0" ufocc="0" />
<FLD name="UPULL" seqno="26" type="S" level="2" pack="0" scale="0" length="16"
 pointer="0" inum="0" ufocc="0" />
<FLD name="HIDESTACK" seqno="27" type="S" level="2" pack="0" scale="0" length="1"
 pointer="0" inum="0" ufocc="0" />
<FLD name="TEMPLATENAME" seqno="28" type="S" level="2" pack="0" scale="0" length="16"
 pointer="0" inum="1" ufocc="0" idxnum="2" idxsnr="1" />
<FLD name="UINHERIT" seqno="29" type="B" level="2" pack="0" scale="0" length="1"
 pointer="0" inum="0" ufocc="0" />
<FLD name="LIBRAR" seqno="30" type="S" level="2" pack="0" scale="0" length="16"
 pointer="0" inum="0" ufocc="0" />
<FLD name="UTRANSACT" seqno="31" type="S" level="2" pack="0" scale="0" length="8"
 pointer="0" inum="0" ufocc="0" />
<FLD name="TPLACTUAL" seqno="32" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\D3,0,0,0,,0,0,0,," />
<FLD name="CONSTRAINTS" seqno="33" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\D4,0,0,0,,0,0,0,," />
<FLD name="INIT" seqno="34" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\C1,0,0,0,,0,0,0,," />
<FLD name="CLEAR" seqno="35" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\C2,0,0,0,,0,0,0,," />
<FLD name="RETRIEVE" seqno="36" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\C3,0,0,0,,0,0,0,," />
<FLD name="RECORD" seqno="37" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\C4,0,0,0,,0,0,0,," />
<FLD name="STORE" seqno="38" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\C5,0,0,0,,0,0,0,," />
<FLD name="DELET" seqno="39" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\C6,0,0,0,,0,0,0,," />
<FLD name="ACCEPT" seqno="40" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\C7,0,0,0,,0,0,0,," />
<FLD name="QUIT" seqno="41" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\C8,0,0,0,,0,0,0,," />
<FLD name="MENU" seqno="42" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\C9,0,0,0,,0,0,0,," />
<FLD name="INTKEY" seqno="43" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\CA,0,0,0,,0,0,0,," />
<FLD name="SPRINT" seqno="44" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\CB,0,0,0,,0,0,0,," />
<FLD name="EPRINT" seqno="45" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\CC,0,0,0,,0,0,0,," />
<FLD name="ASYNC" seqno="46" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\CD,0,0,0,,0,0,0,," />
<FLD name="GENERAL" seqno="47" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\CE,0,0,0,,0,0,0,," />
<FLD name="FORMPIC" seqno="48" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\E0,0,0,0,,0,0,0,," />
<FLD name="HEADER" seqno="49" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\E3,0,0,0,,0,0,0,," />
<FLD name="LISTING" seqno="50" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\E5,0,0,0,,0,0,0,," />
<FLD name="PERF" seqno="51" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\E1,0,0,0,,0,0,0,," />
<FLD name="PROTO" seqno="52" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\E2,0,0,0,,0,0,0,," />
<FLD name="TITLE" seqno="53" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\E7,0,0,0,,0,0,0,," />
<FLD name="WINPROP" seqno="54" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\D2,0,0,0,,0,0,0,," />
<FLD name="FRLF" seqno="55" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\E4,0,0,0,,0,0,0,," />
<FLD name="FRGF" seqno="56" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\E6,0,0,0,,0,0,0,," />
<FLD name="SFUNC" seqno="57" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\DC,0,0,0,,0,0,0,," />
<FLD name="HTMLPROP" seqno="58" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\DD,0,0,0,,0,0,0,," />
<FLD name="USCONTAINED" seqno="59" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\CF,0,0,0,,0,0,0,," />
<FLD name="UEXECDEF" seqno="60" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\D0,0,0,0,,0,0,0,," />
<FLD name="UPOPUP" seqno="61" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\D5,0,0,0,,0,0,0,," />
<FLD name="UML_DATA" seqno="62" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\D6,0,0,0,,0,0,0,," />
<FLD name="HTML_CMPPROP" seqno="63" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\D1,0,0,0,,0,0,0,," />
<FLD name="HTML_FORMAT" seqno="64" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\D7,0,0,0,,0,0,0,," />
<FLD name="HTML_STYLES" seqno="65" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\D8,0,0,0,,0,0,0,," />
<FLD name="HTML_HOOK_H" seqno="66" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\D9,0,0,0,,0,0,0,," />
<FLD name="HTML_HOOK_B" seqno="67" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\DA,0,0,0,,0,0,0,," />
<FLD name="HTML_HOOK_E" seqno="68" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\DB,0,0,0,,0,0,0,," />
<FLD name="HTML_BODYHOOK" seqno="69" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\DE,0,0,0,,0,0,0,," />
<FLD name="HTML_CMPCLASS" seqno="70" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\DF,0,0,0,,0,0,0,," />
<FLD name="GETSTATE" seqno="71" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\E8,0,0,0,,0,0,0,," />
<FLD name="SETSTATE" seqno="72" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\E9,0,0,0,,0,0,0,," />
<FLD name="UNOSTATE" seqno="73" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\EA,0,0,0,,0,0,0,," />
<FLD name="CMP_EXT" seqno="74" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\EB,0,0,0,,0,0,0,," />
<FLD name="UCTRIGGERS" seqno="75" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\EC,0,0,0,,0,0,0,," />
<FLD name="UACCESSPATH" seqno="76" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\ED,0,0,0,,0,0,0,," />
<FLD name="USPLITPROP" seqno="77" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\EE,0,0,0,,0,0,0,," />
<FLD name="TPLACTUAL2" seqno="78" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\EF,0,0,0,,0,0,0,," />
<FLD name="USTATEMANAGEDBY" seqno="79" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\F0,0,0,0,,0,0,0,," />
<FLD name="HTMLSKELETON" seqno="80" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\F1,0,0,0,,0,0,0,," />
</DSC>
<OCC>
<DAT name="UTIMESTAMP">2015-08-18T12:53:54.00</DAT>
<DAT name="UCOMPSTAMP">2015-08-18T13:53:54.00</DAT>
<DAT name="ULABEL">DROPBOX_SVC</DAT>
<DAT name="WVPOS">0</DAT>
<DAT name="WHPOS">0</DAT>
<DAT name="WVSIZ">10</DAT>
<DAT name="WHSIZ">40</DAT>
<DAT name="CLRSCRN">N</DAT>
<DAT name="UBORDER">N</DAT>
<DAT name="UINHERIT">F</DAT>
<DAT name="UTRANSACT">1</DAT>
<DAT name="TPLACTUAL" xml:space='preserve'>
#Comment ----------------------------------------------
#Comment start_of_references
#ifdefined TEMPLATENAME
#info symbol TEMPLATENAME is already or also defined as a global or local constant
#endif
#define TEMPLATENAME=
#Comment 

#Comment end_of_references


#Comment ----------------------------------------------
#Comment start_of_mappings
#Comment end_of_mappings


#Comment ----------------------------------------------
#Comment start_of_symbols
#Comment end_of_symbols


#Comment ----------------------------------------------
</DAT>
<DAT name="GENERAL" xml:space='preserve'>;----------------------------------------------------------------------------------------------------
;
;----------------------------------------------------------------------------------------------------
entry lpDoGet
;----------------------------------------------------------------------------------------------------
params
	String pUrl        : IN
	Struct pParameters : IN
	Struct pReturn     : OUT
endparams

variables
	String  vContent
	String  vHeaders
	String  vResponse
	Numeric vStatus
endvariables

	; Create list of headers
	vHeaders = lpInitHeaders()

	;Append parameters to the URL as a query string
	call lpAppendQueryString(pUrl, pParameters)

	; Make the call to Dropbox
	vStatus = $UHTTP$-&gt;send(pUrl, "GET", "", "", vHeaders, vContent, vResponse)
	if(vStatus == 1)
		message/error "UHTTP got too much data"
	elseif(vStatus &lt; 0)
		message/error "UHTTP returned: %%$status%%%"
	endif
	;TODO: Trap errors

	; Convert return values to a struct
	jsonToStruct pReturn, vContent
	if($status &lt; 0)
		;TODO: Trap errors
		pReturn = $newstruct
	endif

	return vStatus

end ;lpDoGet


;----------------------------------------------------------------------------------------------------
; TODO: Implement chunked transfer
;----------------------------------------------------------------------------------------------------
entry lpDoGetFile
;----------------------------------------------------------------------------------------------------
params
	String pUrl        : IN
	Struct pParameters : IN
	String pDumpPath   : IN
	Struct pReturn     : OUT
endparams

variables
	String  vHeaders
	String  vResponse
	Numeric vStatus
	String  vMetaData
endvariables

	; Create list of headers
	vHeaders = lpInitHeaders()

	;Append parameters to the URL as a query string
	call lpAppendQueryString(pUrl, pParameters)

	$UHTTP$-&gt;dump_file_contents(pDumpPath, "")
	;TODO: Trap errors

	; Make the call to Dropbox
	vStatus = $UHTTP$-&gt;send(pUrl, "GET", "", "", vHeaders, "", vResponse)
	if(vStatus == 1)
		message/error "UHTTP got too much data"
	elseif(vStatus &lt; 0)
		message/error "UHTTP returned: %%$status%%%"
	endif

	$UHTTP$-&gt;DUMP_FILE_CONTENTS("", "")
	;TODO: Trap errors

	vMetaData = $item("x-dropbox-metadata", vHeaders)
	jsonToStruct pReturn, vMetaData
	;TODO: Trap errors

	return 0

end ;lpDoGetFile


;----------------------------------------------------------------------------------------------------
entry lpDoPost
;----------------------------------------------------------------------------------------------------
params
	String pUrl        : IN
	Struct pParameters : IN
	Struct pReturn     : OUT
endparams

variables
	String  vContent
	String  vHeaders
	String  vResponse
	Numeric vStatus
	Numeric vCount
	Numeric vNumberOfParams
endvariables

	;Create list of headers
	vHeaders = lpInitHeaders()
	putitem/id vHeaders, "Content-Type", "application/x-www-form-urlencoded"

	vContent = lpStructToQueryString(pParameters)

	; Call the UHTTP.SEND operation
	vStatus = $UHTTP$-&gt;send(pUrl, "POST", "", "", vHeaders, vContent, vResponse)
	if(vStatus == 1)
		message/error "UHTTP got too much data"
	elseif(vStatus &lt; 0)
		message/error "UHTTP returned: %%$status%%%"
	endif
	;TODO: Trap errors

	jsonToStruct pReturn, vContent
	;TODO: Trap errors

	return vStatus

end ;lpDoPost


;----------------------------------------------------------------------------------------------------
;
;----------------------------------------------------------------------------------------------------
entry lpDoPut
;----------------------------------------------------------------------------------------------------
params
	String pUrl        : IN
	Struct pParameters : IN
	Struct pReturn     : OUT
endparams

variables
	Numeric vLen
	String  vQueryString
	String  vContent
	String  vHeaders
	String  vResponse
	Numeric vStatus
	Numeric vCount
	Numeric vNumberOfParams
endvariables

	;Get its length so we can set the Content-Length request header
	vLen = $UHTTP$-&gt;GET_INFO("LENGTH", "")
	;TODO: Trap errors

	; Create list of headers
	vHeaders = lpInitHeaders()
	putitem/id vHeaders, "Content-Length", vLen
	putitem/id vHeaders, "Content-Type",   "application/octet-stream"

	;Append parameters to the URL as a query string
	call lpAppendQueryString(pUrl, pParameters)
	
	; Call the UHTTP.SEND operation
	vStatus = $UHTTP$-&gt;send(pUrl, "PUT", "", "", vHeaders, vContent, vResponse)
	if(vStatus == 1)
		message/error "UHTTP got too much data"
	elseif(vStatus &lt; 0)
		message/error "UHTTP returned: %%$status%%%"
	endif
	;TODO: Trap errors

	jsonToStruct pReturn, vContent
	;TODO: Trap errors

	return vStatus

end ;lpDoPut


;----------------------------------------------------------------------------------------------------
;
;----------------------------------------------------------------------------------------------------
entry lpInitHeaders
;----------------------------------------------------------------------------------------------------
returns String

variables
	String vHeaders
endvariables

	putitem/id vHeaders, "User-Agent",    $USER_AGENT$
	if($TOKEN$ != "")
		putitem/id vHeaders, "Authorization", $concat("Bearer ", $TOKEN$)
	endif

	return vHeaders

end ;lpInitHeaders


;----------------------------------------------------------------------------------------------------
; Add the parameters in the struct pParameters to pUrl as a query string
;----------------------------------------------------------------------------------------------------
entry lpAppendQueryString
;----------------------------------------------------------------------------------------------------
params
	String pUrl        : INOUT
	Struct pParameters : IN
endparams

variables
	Numeric vCount
	Numeric vNumberOfParams
	String  vQueryString
endvariables

	vQueryString = lpStructToQueryString(pParameters)

	if(vQueryString != "")
		pUrl = $concat(pUrl, "?", vQueryString)
	endif

	return 0

end ;lpAppendQueryString


;----------------------------------------------------------------------------------------------------
entry lpStructToQueryString
;----------------------------------------------------------------------------------------------------
returns String

params
	Struct pParameters : IN
endparams

variables
	Numeric vCount
	Numeric vNumberOfParams
	String  vQueryString
endvariables

	vCount          = 1
	vNumberOfParams = pParameters-&gt;*-&gt;$collsize

	while(vCount &lt;= vNumberOfParams)

		putitem/id vQueryString, pParameters-&gt;*{vCount}-&gt;$name, pParameters-&gt;*{vCount}

		vCount = vCount + 1

	endwhile

	vQueryString = $replace(vQueryString, 1, "&uSEP;", "&amp;", -1)

	return vQueryString

end ;lpStructToQueryString


;TODO:
;public string	
;#appendFilePath( string $base, string $path )
;Given a $base path for an API endpoint (for example, "/files"), append a Dropbox API file path to the end of that URL. Special characters in the file will be encoded properly.</DAT>
<DAT name="FORMPIC" xml:space='preserve'>
 &uFRM;TYP=E&uSEP;NAM=DUMMY.DUMMY&uSEP;WID=20&uSEP;HEI=1&uSEP;HOC=20&uSEP;VOC=1&uFRM;</DAT>
<DAT name="SFUNC" xml:space='preserve'>;----------------------------------------------------------------------------------------------------
; Set API URLs and create an instance of UHTTP
;----------------------------------------------------------------------------------------------------
operation init
;----------------------------------------------------------------------------------------------------

	$API_URL$           = "https://api.dropbox.com/1/"
	$API_CONTENT_URL$   = "https://api-content.dropbox.com/1/"
	$API_AUTHORISE_URL$ = "https://www.dropbox.com/1/"
	$USER_AGENT$        = "Dropbox-Uniface-SDK/0.1-9.6"

	newinstance "UHTTP", $UHTTP$
	$UHTTP$-&gt;SET_FLAGS(8) ;Send headers with all HTTP methods

	return 0

end ;init


;----------------------------------------------------------------------------------------------------
; Having aquired an OAuth token, use this operation to pass it to this service for use
; in subsequent calls.
;----------------------------------------------------------------------------------------------------
operation setAccessToken
;----------------------------------------------------------------------------------------------------
params
	String pToken : IN
endparams

	$TOKEN$ = pToken

	return 0

end ;setAccessToken


;----------------------------------------------------------------------------------------------------
; An identifier for the API client, typically of the form "Name/Version". This is used to set the
; HTTP User-Agent header when making API requests. Example: "PhotoEditServer/1.3"
;----------------------------------------------------------------------------------------------------
operation setClientIdentifier
;----------------------------------------------------------------------------------------------------
params
	String pClientIdentifier : IN
endparams

	$USER_AGENT$ = pClientIdentifier

	return 0

end ;setClientIdentifier


;----------------------------------------------------------------------------------------------------
; The locale of the user of your application. Some API calls return localized data and error
; messages; this "user locale" setting determines which locale the server should use to localize
; those strings.
;----------------------------------------------------------------------------------------------------
operation setUserLocale
;----------------------------------------------------------------------------------------------------
params
	String pUserLocale : IN
endparams

	$LOCALE$ = pUserLocale

	return 0

end ;setUserLocale


;----------------------------------------------------------------------------------------------------
; DESCRIPTION
;  This starts the OAuth 2.0 authorization flow. This isn't an API call—it's the web page that lets
;  the user sign in to Dropbox and authorize your app. After the user decides whether or not to
;  authorize your app, they will be redirected to the URI specified by redirect_uri.
;
;  OAuth 2.0 supports two authorization flows:
;
;  The code flow returns a code via the redirect_uri callback which should then be converted into a
;  bearer token using the /oauth2/token call. This is the recommended flow for apps that are running
;  on a server.
;  The token or implicit grant flow returns the bearer token via the redirect_uri callback, rather
;  than requiring your app to make a second call to a server. This is useful for pure client-side
;  apps, such as mobile apps or JavaScript-based apps.
;  For more information on the two flows, see Section 1.3 of the OAuth 2 spec.
;
; PARAMETERS
;  pResponseType  The grant type requested, either token or code.
;  pClientId      The app's key, found in the App Console.
;  pOptions       Additional optional options
;    redirect_uri    - Where to redirect the user after authorization has completed. This must
;                      be the exact URI registered in the App Console; even 'localhost' must be
;                      listed if it is used for testing. A redirect URI is required for a token
;                      flow, but optional for code. If the redirect URI is omitted, the code
;                      will be presented directly to the user and they will be invited to enter
;                      the information in your app.
;    state           - Up to 500 bytes of arbitrary data that will be passed back to your
;                      redirect URI. This parameter should be used to protect against cross-site
;                      request forgery (CSRF). See Sections 4.4.1.8 and 4.4.2.5 of the OAuth 2.0
;                      threat model spec.
;    require_role    - If specified, the user will be asked to authorize with a particular type
;                      of Dropbox account, either work for a Dropbox for Business account or
;                      personal for a personal account. Your app should still verify the type of
;                      Dropbox account after authorization since the user could modify or remove
;                      the require_role parameter.
;    force_reapprove - Whether or not to force the user to approve the app again if they've
;                      already done so. If false (default), a user who has already approved the
;                      application may be automatically redirected to the URI specified by
;                      redirect_uri. If true, the user will not be automatically redirected and
;                      will have to approve the app again.
;    disable_signup  - When true (default is false) users will not be able to sign up for a
;                      Dropbox account via the authorization page. Instead, the authorization
;                      page will show a link to the Dropbox iOS app in the App Store. This is
;                      only intended for use when necessary for compliance with App Store
;                      policies.
;
; RETURNS
;  Because /oauth2/authorize is a website, there is no direct return value. However, after the user
;  authorizes your app, they will be sent to your redirect URI. The type of response varies based on
;  the response_type.
;
;  Code flow
;  These parameters are passed in the query string (after the ? in the URL):
;
;  code  - The authorization code, which can be used to attain a bearer token by calling
;          /oauth2/token.
;  state - The state content, if any, originally passed to /oauth2/authorize.
;
;  Sample response
;  [REDIRECT_URI]?code=ABCDEFG&amp;state=[STATE]

;  Token flow
;  These parameters are passed in the URL fragment (after the # in the URL):
;
;  access_token - A token which can be used to make calls to the Dropbox API.
;  token_type   - The type of token, which will always be bearer.
;  uid          - The Dropbox user ID of the authorized user.
;  state        - The state content, if any, originally passed to /oauth2/authorize.
;
;  Sample response
;  [REDIRECT_URI]#access_token=ABCDEFG&amp;token_type=bearer&amp;uid=12345&amp;state=[STATE]

; ERRORS
;  In either flow, if an error occurs, including if the user has chosen not to authorize the app, the
;  following parameters will be included in the redirect URI:
;
;  error             - An error code per Section 4.1.2.1 of the OAuth 2.0 spec.
;  error_description - A user-friendly description of the error that occurred.
;  state             - The state content, if any, originally passed to /oauth2/authorize.
;----------------------------------------------------------------------------------------------------
operation oauth2Authorize
;----------------------------------------------------------------------------------------------------
params
	String pResponseType : IN
	String pClientId     : IN
	Struct pOptions      : IN
	String pUrl          : OUT
endparams

	;TODO: pResponseType and pClientId are mandatory

	;Add the mandatory params to the options struct
	pOptions-&gt;"response_type" = pResponseType
	pOptions-&gt;"client_id"     = pClientId

	pUrl = $concat($API_AUTHORISE_URL$, "oauth2/authorize")

	;Append all the options to the URL
	call lpAppendQueryString(pUrl, pOptions)

	return 0

end ;oauth2Authorize


;----------------------------------------------------------------------------------------------------
; DESCRIPTION
;  This endpoint only applies to apps using the authorization code flow. An app calls this endpoint
;  to acquire a bearer token once the user has authorized the app.
;
;  Calls to /oauth2/token need to be authenticated using the apps's key and secret. These can either
;  be passed as POST parameters (see parameters below) or via HTTP basic authentication. If basic
;  authentication is used, the app key should be provided as the username, and the app secret should
;  be provided as the password.
;
; PARAMETERS
;  pCode          The code acquired by directing users to /oauth2/authorize?response_type=code.
;  pClientId      The app's key (found in the App Console).
;  pClientSecret  The app's secret (found in the App Console).
;  pOptions       Additional optional options
;    grant_type    - The grant type, which must be authorization_code.
;    redirect_uri  - Only used to validate that it matches the original /oauth2/authorize, not used
;                    to redirect again.
;
; RETURNS
;  access_token - access token
;  token_type   - token type
;  uid          - Dropbox user ID
;
; ERRORS
;  error
;  error_description
;----------------------------------------------------------------------------------------------------
operation oauth2Token
;----------------------------------------------------------------------------------------------------
params
	String pCode         : IN
	String pClientId     : IN
	String pClientSecret : IN
	Struct pOptions      : IN
	Struct pReturn       : OUT
endparams

variables
	String vUrl
	Struct vParameters
	Struct vReturn
endvariables

	;TODO: Check mandatory parameters

	vUrl = $concat($API_URL$, "oauth2/token")

	;Stash mandatory params in options struct before passing to lpDoPost
	pOptions-&gt;"code"          = pCode
	pOptions-&gt;"client_id"     = pClientId
	pOptions-&gt;"client_secret" = pClientSecret
	;grant_type currently has to be set to this
	pOptions-&gt;"grant_type"    = "authorization_code"

	call lpDoPost(vUrl, pOptions, pReturn)
	;TODO: Trap errors

	return 0

end ;oauth2Token


;----------------------------------------------------------------------------------------------------
; Make an API call to get basic account and quota information.
;----------------------------------------------------------------------------------------------------
operation getAccountInfo
;----------------------------------------------------------------------------------------------------
params
	Struct pReturn : OUT
endparams

variables
	String vUrl
endvariables

	vUrl = $concat($API_URL$, "account/info")
	call lpDoGet(vUrl, "", pReturn)
	;TODO: Trap errors

	return 0

end ;getAccountInfo


;----------------------------------------------------------------------------------------------------
; Downloads a file from Dropbox. The file's contents are written to the pDumpPath and the file's
; metadata is returned in pReturn.
;
; PARAMETERS
;  pPath      The path to the file you want to retrieve.
;  pDumpPath  The path to dump the file to
;  pOptions   Additional optional options
;    rev - The revision of the file to retrieve. This defaults to the most recent revision.
;
; RETURNS
;  pReturn    Contains the content metadata
;
;TODO: Handle pOptions-&gt;"rev" option
;TODO: Implement HTTP Range Retrieval for retrieving partial file contents
;----------------------------------------------------------------------------------------------------
operation getFile
;----------------------------------------------------------------------------------------------------
params
	String pPath     : IN
	String pDumpPath : IN
	Struct pOptions  : IN
	Struct pReturn   : OUT
endparams

variables
	String vUrl
endvariables

	vUrl = $concat($API_CONTENT_URL$, "files/auto/", pPath)

	call lpDoGetFile(vUrl, "", pDumpPath, pReturn)

	return 0

end ;getFile


;----------------------------------------------------------------------------------------------------
; Returns the metadata for whatever file or folder is at the given path.
;
; PARAMETERS
; pPath     The remote path to return metadata for. Can be a file or a folder.
; pOptions  Additional optional options
;   file_limit         - Default is 10,000 (max is 25,000). When listing a folder, the service won't
;                        report listings containing more than the specified amount of files and will
;                        instead respond with a 406 (Not Acceptable) status response.
;   rev                - If you include a particular revision number, then only the metadata for that
;                        revision will be returned.
;   include_media_info - If true, each file will include a photo_info dictionary for photos and a
;                        video_info dictionary for videos with additional media info. If the data isn't
;                        available yet, the string pending will be returned instead of a dictionary.
;   include_membership - If true, metadata for a shared folder will include a list of members and a list
;                        of groups.
;
;   hash               - Each call to /metadata on a folder will return a hash field, generated by
;                        hashing all of the metadata contained in that response. On later calls to
;                        /metadata, you should provide that value via this parameter so that if
;                        nothing has changed, the response will be a 304 (Not Modified) status code
;                        instead of the full, potentially very large, folder listing. This parameter
;                        is ignored if the specified path is associated with a file or if list=false.
;   list               - The strings true and false are valid values. true is the default. If true, the
;                        folder's metadata will include a contents field with a list of metadata entries for
;                        the contents of the folder. If false, the contents field will be omitted.
;   include_deleted    - Only applicable when list is set. If this parameter is set to true, then contents
;                        will include the metadata of deleted children. Note that the target of the metadata
;                        call is always returned even when it has been deleted (with is_deleted set to true)
;                        regardless of this flag.
;
; RETURNS
;  The metadata for the file or folder at pPath. If pPath represents a folder and the
;  list parameter is true, the metadata will also include a listing of metadata for the folder's
;  contents.
;
;  304 - Not Modified
;----------------------------------------------------------------------------------------------------
operation getMetadata
;----------------------------------------------------------------------------------------------------
params
	String pPath    : IN
	Struct pOptions : IN
	Struct pReturns : OUT
endparams

variables
	String  vUrl
	Numeric vStatus
endvariables

	vUrl = $concat($API_URL$, "metadata/auto/", pPath)
	call lpDoGet(vUrl, pOptions, pReturns)
	vStatus = $status

	return vStatus

end ;getMetadata


;----------------------------------------------------------------------------------------------------
; Returns the metadata for whatever file or folder is at the given path and, if it's a folder,
; also include the metadata for all the immediate children of that folder.
;
; PARAMETERS
; pPath     The remote path to return metadata for. Can be a file or a folder.
; pOptions  Additional optional options. Any options for getMetadata are valid, as well as those
;           listed below
;   include_deleted    - If this parameter is set to true, then contents will include the metadata
;                        of deleted children. Note that the target of the metadata call is always
;                        returned even when it has been deleted (with is_deleted set to true)
;                        regardless of this flag.
;
; RETURNS
;  See getMetadata
;----------------------------------------------------------------------------------------------------
operation getMetadataWithChildren
;----------------------------------------------------------------------------------------------------
params
	String pPath    : IN
	Struct pOptions : IN
	Struct pReturns : OUT
endparams

	pOptions-&gt;"list" = "true"

	$instancehandle-&gt;getMetadata(pPath, pOptions, pReturns)
	return $status

end ;getMetadataWithChildren


;----------------------------------------------------------------------------------------------------
; If you've previously retrieved the metadata for a folder and its children, this method will
; retrieve updated metadata only if something has changed. This is more efficient than calling
; getMetadataWithChildren() if you have a cache of previous results.
;
; PARAMETERS
; pPath     The remote path to return metadata for. Can be a file or a folder.
; pOptions  Additional optional options. Any options for getMetadata are valid, as well as those
;           listed below
;   include_deleted    - If this parameter is set to true, then contents will include the metadata
;                        of deleted children. Note that the target of the metadata call is always
;                        returned even when it has been deleted (with is_deleted set to true)
;                        regardless of this flag.
;
; RETURNS
;  See getMetadata
;----------------------------------------------------------------------------------------------------
operation getMetadataWithChildrenIfChanged
;----------------------------------------------------------------------------------------------------
params
	String pPath               : IN
	String pPreviousFolderHash : IN
	Struct pOptions            : IN
	Struct pReturns            : OUT
endparams

	pOptions-&gt;"list" = "true"
	pOptions-&gt;"hash" = pPreviousFolderHash

	$instancehandle-&gt;getMetadata(pPath, pOptions, pReturns)
	return $status

end ;getMetadataWithChildrenIfChanged


;----------------------------------------------------------------------------------------------------
; Gets a thumbnail image representation of the file at the given path.
;
; PARAMETERS
; pPath      The path to the image file you want to thumbnail
; pDumpPath  The path to dump the file to
; pOptions   Additional optional options
;    format - jpeg (default) or png. For images that are photos, jpeg should be preferred, while png
;             is better for screenshots and digital art.
;    size   - One of the following values (default: s):
;             value  dimensions (px)
;               xs     32x32
;               s      64x64
;               m      128x128
;               l      640x480
;               xl     1024x768
;----------------------------------------------------------------------------------------------------
operation getThumbnail
;----------------------------------------------------------------------------------------------------
params
	String pPath     : IN
	String pDumpPath : IN
	Struct pOptions  : IN
	Struct pReturn   : OUT
endparams

variables
	String  vUrl
endvariables

	vUrl = $concat($API_CONTENT_URL$, "thumbnails/auto/", pPath)

	call lpDoGetFile(vUrl, pOptions, pDumpPath, pReturn)

	return 0

end ;getThumbnail


;----------------------------------------------------------------------------------------------------
; Make an API call to disable the access token that you constructed this service with. After calling
; this, API calls made with this Client will fail.
;----------------------------------------------------------------------------------------------------
operation disableAccessToken
;----------------------------------------------------------------------------------------------------
variables
	String  vUrl
endvariables

	vUrl = $concat($API_CONTENT_URL$, "disable_access_token/")

	call lpDoPost(vUrl, "", "")

	return 0

end ;disableAccessToken


;----------------------------------------------------------------------------------------------------
; Creates a file on Dropbox, using the file found at pSourcePath
;
; PARAMETERS
; pPath          Where in the user's Dropbox to upload the file to
; pSourcePath    The location of the file to upload on the local disc
; pOptions       Additional optional options
;    overwrite  - This value, either true (default) or false, determines whether an existing file
;                 will be overwritten by this upload. If true, any existing file will be overwritten.
;                 If false, the other parameters determine whether a conflict occurs and how that
;                 conflict is resolved.
;    parent_rev - If present, this parameter specifies the revision of the file you're editing. If
;                 parent_rev matches the latest version of the file on the user's Dropbox, that file
;                 will be replaced. Otherwise, a conflict will occur. (See below.) If you specify a
;                 parent_rev and that revision doesn't exist, the file won't save (error 400). You can
;                 get the most recent rev by performing a call to /metadata.
;    autorename - This value, either true (default) or false, determines what happens when there is a
;                 conflict. If true, the file being uploaded will be automatically renamed to avoid the
;                 conflict. (For example, test.txt might be automatically renamed to test (1).txt.) The
;                 new name can be obtained from the returned metadata. If false, the call will fail with
;                 a 409 (Conflict) response code.
;----------------------------------------------------------------------------------------------------
operation uploadFile
;----------------------------------------------------------------------------------------------------
params
	String pPath       : IN
	String pSourcePath : IN
	Struct pOptions    : IN
	Struct pReturn     : OUT
endparams

variables
	String vUrl
endvariables

	vUrl = $concat($API_CONTENT_URL$, "files_put/auto/", pPath)

	;Load up the file we're "putting"
	$UHTTP$-&gt;LOAD_FILE_CONTENTS(pSourcePath, "segm=10k")
	;TODO: Trap errors

	call lpDoPut(vUrl, pOptions, pReturn)

	return 0

end ;uploadFile


;----------------------------------------------------------------------------------------------------
; Creates a file on Dropbox, using the file found at pSourcePath. Dropbox's chunked upload methods
; will be used. Use this for files over 150Mb or where you'd like to be able to get progress
; information or retry failed uploads.
;
; PARAMETERS
; pPath          Where in the user's Dropbox to upload the file to
; pSourcePath    The location of the file to upload on the local disc
; pOptions       Additional optional options. See "uploadFile" for base options.
;    chunk_size         - The number of bytes to upload in each chunk
;    callback_instance  - If specified this instance will be notified of the progress of the upload
;    callback_operation - The operation the progress notifier should call
;----------------------------------------------------------------------------------------------------
operation uploadFileChunked
;----------------------------------------------------------------------------------------------------
params
	String  pPath       : IN
	String  pSourcePath : IN
	Struct  pOptions    : IN
	Struct  pReturn     : OUT
endparams

variables
	String  vCallbackInstance
	String  vCallbackOperation
	String  vChunk
	String  vOptions
	Numeric vLen
	Numeric vOffset
	String  vUrl
	Struct  vReturn
	String  vUploadId
	Struct  vParameters
endvariables

	vCallbackInstance  = pOptions-&gt;"callback_instance"
	vCallbackOperation = pOptions-&gt;"callback_operation"
	vChunk             = pOptions-&gt;"chunk_size"

	if(vChunk == "")
		vChunk = "4m"
	endif
	
	;Set the chunk size
	putitem/id vOptions, "CHUNK", vChunk

	;Get the size of the file we're uploading
	vLen = $item( "FILESIZE", $fileproperties(pSourcePath) )

	;Do the chunked upload
	vParameters = $newstruct
	vOffset     = 0
	vUrl        = $concat($API_CONTENT_URL$, "chunked_upload/")

	while(vOffset &lt; vLen)

		if(vCallbackInstance != "")
			activate "%%vCallbackInstance%%%"."%%vCallbackOperation%%%"(vOffset, vLen)
		endif

		putitem/id vOptions, "STARTAT", vOffset
		$UHTTP$-&gt;LOAD_FILE_CONTENTS(pSourcePath, vOptions)

		call lpDoPut(vUrl, vParameters, vReturn)
		;ERRORS
		;404	The upload_id does not exist or has expired.
		;400	The offset parameter does not match up with what the server expects. The body of the
		;      error response will be JSON similar to the above, indicating the correct offset to upload.		

		vUploadId = vReturn-&gt;"upload_id"
		vOffset   = vReturn-&gt;"offset"

		vParameters-&gt;"upload_id" = vUploadId
		vParameters-&gt;"offset"    = vOffset

	endwhile

	$UHTTP$-&gt;CLOSE_FILE()

	;Commit upload
	vParameters = $newstruct
	vParameters-&gt;"overwrite"  = pOptions-&gt;"overwrite"
	vParameters-&gt;"parent_rev" = pOptions-&gt;"parent_rev"
	vParameters-&gt;"autorename" = pOptions-&gt;"autorename"
	vParameters-&gt;"upload_id"  = vUploadId

	vUrl = $concat($API_CONTENT_URL$, "commit_chunked_upload/auto/", pPath)
	call lpDoPost(vUrl, vParameters, pReturn)

	if(vCallbackInstance != "")
		activate "%%vCallbackInstance%%%"."%%vCallbackOperation%%%"(vOffset, vLen)
	endif

	return 0

end ;uploadFileChunked


;----------------------------------------------------------------------------------------------------
; Creates a folder.
;
; PARAMETERS
; pPath  The path of the folder to create
;----------------------------------------------------------------------------------------------------
operation createFolder
;----------------------------------------------------------------------------------------------------
params
	String pPath   : IN
	Struct pReturn : OUT
endparams

variables
	String vUrl
	Struct vOptions
endvariables

	if(pPath == "")
		return -1
	endif

	vUrl = $concat($API_URL$, "fileops/create_folder/")

	vOptions = $newstruct
	vOptions-&gt;"path" = pPath
	vOptions-&gt;"root" = "auto"

	call lpDoPost(vUrl, vOptions, pReturn)

	return 0

end ;createFolder


;----------------------------------------------------------------------------------------------------
; Deletes a file or folder
;
; PARAMETERS
; pPath  The path to the file or folder to be deleted
;----------------------------------------------------------------------------------------------------
operation delete
;----------------------------------------------------------------------------------------------------
params
	String pPath   : IN
	Struct pReturn : OUT
endparams

variables
	String vUrl
	Struct vOptions
endvariables

	if(pPath == "")
		return -1
	endif

	vUrl = $concat($API_URL$, "fileops/delete/")

	vOptions = $newstruct
	vOptions-&gt;"path" = pPath
	vOptions-&gt;"root" = "auto"

	call lpDoPost(vUrl, vOptions, pReturn)

	return 0

end ;delete


;----------------------------------------------------------------------------------------------------
; Moves a file or folder to a new location.
;
; PARAMETERS
; pFromPath  Specifies the file or folder to be moved from relative to root.
; pToPath    Specifies the destination path, including the new name for the file or folder, relative
;            to root.
;----------------------------------------------------------------------------------------------------
operation move
;----------------------------------------------------------------------------------------------------
params
	String pFromPath : IN
	String pToPath   : IN
	Struct pReturn   : OUT
endparams

variables
	String vUrl
	Struct vOptions
endvariables

	if(pFromPath == "")
		return -1
	endif

	if(pToPath == "")
		return -1
	endif

	vUrl = $concat($API_URL$, "fileops/move/")

	vOptions = $newstruct
	vOptions-&gt;"from_path" = pFromPath
	vOptions-&gt;"to_path"   = pToPath
	vOptions-&gt;"root"      = "auto"

	call lpDoPost(vUrl, vOptions, pReturn)

	return 0

end ;move


;----------------------------------------------------------------------------------------------------
; Gets the metadata for all the file revisions (up to a limit) for a given path.
;
; PARAMETERS
; pPath    The Dropbox path that you want file revision metadata for.
; pLimit   The maximum number of revisions to return.
;          
; RETURNS  
; pReturn  A list of &lt;a href="https://www.dropbox.com/developers/core/docs#metadata-details&gt;metadata
;          objects&lt;/a&gt;, one for each file revision.  The later revisions appear first in the list.
;          If empty, then there were too many revisions at that path.
;----------------------------------------------------------------------------------------------------
operation getRevisions
;----------------------------------------------------------------------------------------------------
params
	String  pPath   : IN
	Numeric pLimit  : IN
	Struct  pReturn : OUT
endparams

variables
	String vUrl
	Struct vOptions
endvariables

	if(pPath == "")
		return -1
	endif

	vUrl = $concat($API_URL$, "revisions/auto/", pPath)

	vOptions = $newstruct
	if(pLimit != "")
		vOptions-&gt;"rev_limit" = pLimit
	endif

	call lpDoGet(vUrl, vOptions, pReturn)

	return 0

end ;getRevisions


;----------------------------------------------------------------------------------------------------
; Takes a copy of the file at the given revision and saves it over the current copy. This will create
; a new revision, but the file contents will match the revision you specified.
;
; PARAMETERS
; pPath  The Dropbox path of the file to restore.
; pRev   The revision to restore the contents to.
;----------------------------------------------------------------------------------------------------
operation restoreFile
;----------------------------------------------------------------------------------------------------
params
	String pPath   : IN
	String pRev    : IN
	Struct pReturn : OUT
endparams

variables
	String vUrl
	Struct vOptions
endvariables

	if(pPath == "")
		return -1
	endif

	if(pRev == "")
		return -1
	endif

	vUrl = $concat($API_URL$, "restore/auto/", pPath)

	vOptions = $newstruct
	vOptions-&gt;"rev" = pRev

	call lpDoPost(vUrl, vOptions, pReturn)

	return 0

end ;restoreFile


;public mixed	
;#searchFileNames( string $basePath, string $query, integer|null $limit = null, boolean $includeDeleted = false )
;Returns metadata for all files and folders whose filename matches the query string.


;public string	
;#createShareableLink( string $path )
;Creates and returns a public link to a file or folder's "preview page". This link can be used without authentication. The preview page may contain a thumbnail or some other preview of the file, along with a download link to download the actual file.


;public array	
;#createTemporaryDirectLink( string $path )
;Creates and returns a direct link to a file. This link can be used without authentication. This link will expire in a few hours.


;public string	
;#createCopyRef( string $path )
;Creates and returns a "copy ref" to a file. A copy ref can be used to copy a file across different Dropbox accounts without downloading and re-uploading.


;public mixed	
;#copy( string $fromPath, string $toPath )
;Copies a file or folder to a new location


;public mixed	
;#copyFromCopyRef( string $copyRef, string $toPath )
;Creates a file or folder based on an existing copy ref (possibly from a different Dropbox account).</DAT>
</OCC>
</TABLE>
<TABLE>
<DSC name="UXGROUP" model="DICT" system="S" pseudo ="73" level="1" noupdate="0"
 rbk="0" ffsql="0" transnr="0" segsize="0" ufocc="1000" charset=".U">
<FLD name="UTIMESTAMP" seqno="1" type="E" level="2" pack="0" scale="0" length="15"
 pointer="0" inum="0" ufocc="0" />
<FLD name="ULABEL" seqno="2" type="S" level="2" pack="0" scale="0" length="32"
 pointer="0" inum="1" ufocc="0" mandatory="yes" idxnum="1" idxsnr="101" />
<FLD name="UBASE" seqno="3" type="S" level="2" pack="0" scale="0" length="32"
 pointer="0" inum="1" ufocc="0" mandatory="yes" idxnum="1" idxsnr="102" />
<FLD name="UFORM" seqno="4" type="S" level="2" pack="0" scale="0" length="16"
 pointer="0" inum="2" ufocc="0" mandatory="yes" idxnum="1,2" idxsnr="103,1" />
<FLD name="UVERS" seqno="5" type="S" level="2" pack="0" scale="0" length="12"
 pointer="0" inum="0" ufocc="0" />
<FLD name="UDESCR" seqno="6" type="S" level="2" pack="0" scale="0" length="25"
 pointer="0" inum="0" ufocc="0" />
<FLD name="U_BORD" seqno="7" type="S" level="2" pack="0" scale="0" length="1"
 pointer="0" inum="0" ufocc="0" />
<FLD name="U_INDB" seqno="8" type="S" level="2" pack="0" scale="0" length="1"
 pointer="0" inum="0" ufocc="0" />
<FLD name="U_DBMS" seqno="9" type="S" level="2" pack="0" scale="0" length="3"
 pointer="0" inum="0" ufocc="0" />
<FLD name="U_UPD" seqno="10" type="S" level="2" pack="0" scale="0" length="1"
 pointer="0" inum="0" ufocc="0" />
<FLD name="U_MINL" seqno="11" type="N" level="2" pack="0" scale="0" length="6"
 pointer="0" inum="0" ufocc="0" />
<FLD name="U_MAXL" seqno="12" type="N" level="2" pack="0" scale="0" length="6"
 pointer="0" inum="0" ufocc="0" />
<FLD name="U_MINR" seqno="13" type="N" level="2" pack="0" scale="0" length="6"
 pointer="0" inum="0" ufocc="0" />
<FLD name="U_MAXR" seqno="14" type="N" level="2" pack="0" scale="0" length="6"
 pointer="0" inum="0" ufocc="0" />
<FLD name="TPLGINTF" seqno="15" type="S" level="2" pack="0" scale="0" length="32"
 pointer="0" inum="0" ufocc="0" />
<FLD name="U_INTF" seqno="16" type="S" level="2" pack="0" scale="0" length="64"
 pointer="0" inum="0" ufocc="0" />
<FLD name="TEMPLATENAME" seqno="17" type="S" level="2" pack="0" scale="0" length="32"
 pointer="0" inum="0" ufocc="0" />
<FLD name="UINHERIT" seqno="18" type="B" level="2" pack="0" scale="0" length="1"
 pointer="0" inum="0" ufocc="0" />
<FLD name="TPLACTUAL" seqno="19" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\E6,0,0,0,,0,0,0,," />
<FLD name="GETOCC" seqno="20" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\C1,0,0,0,,0,0,0,," />
<FLD name="PUTOCC" seqno="21" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\C2,0,0,0,,0,0,0,," />
<FLD name="DELOCC" seqno="22" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\C3,0,0,0,,0,0,0,," />
<FLD name="LCK" seqno="23" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\C4,0,0,0,,0,0,0,," />
<FLD name="UNLOCK" seqno="24" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\C5,0,0,0,,0,0,0,," />
<FLD name="GETSEGM" seqno="25" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\C6,0,0,0,,0,0,0,," />
<FLD name="ADDOCC" seqno="26" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\C7,0,0,0,,0,0,0,," />
<FLD name="DELOCCR" seqno="27" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\C8,0,0,0,,0,0,0,," />
<FLD name="ENDMOD" seqno="28" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\C9,0,0,0,,0,0,0,," />
<FLD name="DOC" seqno="29" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\CA,0,0,0,,0,0,0,," />
<FLD name="DETAIL" seqno="30" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\CB,0,0,0,,0,0,0,," />
<FLD name="CREOCC" seqno="31" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\CC,0,0,0,,0,0,0,," />
<FLD name="MENU" seqno="32" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\CD,0,0,0,,0,0,0,," />
<FLD name="FINDOCC" seqno="33" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\CE,0,0,0,,0,0,0,," />
<FLD name="ERROR" seqno="34" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\CF,0,0,0,,0,0,0,," />
<FLD name="GENERAL" seqno="35" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\D0,0,0,0,,0,0,0,," />
<FLD name="STARTMOD" seqno="36" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\D1,0,0,0,,0,0,0,," />
<FLD name="FLIST" seqno="37" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\E1,0,0,0,,0,0,0,," />
<FLD name="BREAK" seqno="38" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\E2,0,0,0,,0,0,0,," />
<FLD name="VLDE" seqno="39" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\D2,0,0,0,,0,0,0,," />
<FLD name="VLDK" seqno="40" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\D3,0,0,0,,0,0,0,," />
<FLD name="UPOPUP" seqno="41" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\D4,0,0,0,,0,0,0,," />
<FLD name="UISBCLASS" seqno="42" type="B" level="2" pack="0" scale="0" length="1"
 pointer="0" inum="0" ufocc="0" />
<FLD name="UISASSOC" seqno="43" type="B" level="2" pack="0" scale="0" length="1"
 pointer="0" inum="0" ufocc="0" />
<FLD name="U_OBJSVC" seqno="44" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\DC,0,0,0,,0,0,0,," />
<FLD name="U_SVCUSE" seqno="45" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\DD,0,0,0,,0,0,0,," />
<FLD name="HTML_ENTPROP" seqno="46" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\D7,0,0,0,,0,0,0,," />
<FLD name="HTML_TABTYPE" seqno="47" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\D8,0,0,0,,0,0,0,," />
<FLD name="HTML_ENTHK_B" seqno="48" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\D9,0,0,0,,0,0,0,," />
<FLD name="HTML_ENTHK_E" seqno="49" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\DA,0,0,0,,0,0,0,," />
<FLD name="HTML_OCCHK_B" seqno="50" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\DB,0,0,0,,0,0,0,," />
<FLD name="HTML_OCCHK_E" seqno="51" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\DE,0,0,0,,0,0,0,," />
<FLD name="HTML_ENTCLASS" seqno="52" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\DF,0,0,0,,0,0,0,," />
<FLD name="U_GLAB" seqno="53" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\E0,0,0,0,,0,0,0,," />
<FLD name="UEOINTERFACE" seqno="54" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\E3,0,0,0,,0,0,0,," />
<FLD name="UECINTERFACE" seqno="55" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\E4,0,0,0,,0,0,0,," />
<FLD name="UEOOPERS" seqno="56" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\E5,0,0,0,,0,0,0,," />
<FLD name="UECOPERS" seqno="57" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\E7,0,0,0,,0,0,0,," />
<FLD name="UEOTRIGGERS" seqno="58" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\E8,0,0,0,,0,0,0,," />
<FLD name="UECTRIGGERS" seqno="59" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\E9,0,0,0,,0,0,0,," />
<FLD name="UGEOMETRY" seqno="60" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\EA,0,0,0,,0,0,0,," />
<FLD name="UWIDGETTYPE" seqno="61" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\EB,0,0,0,,0,0,0,," />
<FLD name="UWIDGETCREATE" seqno="62" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\EC,0,0,0,,0,0,0,," />
<FLD name="PRLO" seqno="63" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\ED,0,0,0,,0,0,0,," />
<FLD name="PSLO" seqno="64" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\EE,0,0,0,,0,0,0,," />
<FLD name="PRSO" seqno="65" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\EF,0,0,0,,0,0,0,," />
<FLD name="PSSO" seqno="66" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\F0,0,0,0,,0,0,0,," />
<FLD name="UPARENT" seqno="67" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\F1,0,0,0,,0,0,0,," />
<FLD name="UWEBWIDGETTYPE" seqno="68" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\F2,0,0,0,,0,0,0,," />
<FLD name="UWEBWIDGETCREATE" seqno="69" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\F3,0,0,0,,0,0,0,," />
</DSC>
<OCC>
<DAT name="UTIMESTAMP">2015-07-24T15:46:37.00</DAT>
<DAT name="ULABEL">DUMMY</DAT>
<DAT name="UBASE">DUMMY</DAT>
<DAT name="UFORM">DROPBOX_SVC</DAT>
<DAT name="U_BORD">N</DAT>
<DAT name="U_INDB">N</DAT>
<DAT name="UINHERIT">F</DAT>
<DAT name="UISBCLASS">F</DAT>
<DAT name="UISASSOC">F</DAT>
<DAT name="HTML_ENTPROP" xml:space='preserve'>U_ATLEASTONE=1&uSEP;U_STARTOCC=1&uSEP;U_MAXOCC=</DAT>
</OCC>
</TABLE>
<TABLE>
<DSC name="UXREGS" model="DICT" system="S" pseudo ="73" level="1" noupdate="0"
 rbk="0" ffsql="0" transnr="0" segsize="0" ufocc="0" charset=".U">
<FLD name="UTIMESTAMP" seqno="1" type="E" level="2" pack="0" scale="0" length="15"
 pointer="0" inum="0" ufocc="0" />
<FLD name="U_STAT" seqno="2" type="S" level="2" pack="0" scale="0" length="4"
 pointer="0" inum="0" ufocc="0" />
<FLD name="U_TYPE" seqno="3" type="S" level="2" pack="0" scale="0" length="2"
 pointer="0" inum="0" ufocc="0" />
<FLD name="U_FORMLIB" seqno="4" type="S" level="2" pack="0" scale="0" length="16"
 pointer="0" inum="2" ufocc="0" mandatory="yes" idxnum="1,3" idxsnr="101,1" />
<FLD name="U_NAME" seqno="5" type="S" level="2" pack="0" scale="0" length="32"
 pointer="0" inum="2" ufocc="0" mandatory="yes" idxnum="1,2" idxsnr="102,1" />
<FLD name="UVERS" seqno="6" type="S" level="2" pack="0" scale="0" length="12"
 pointer="0" inum="0" ufocc="0" />
<FLD name="UDESCR" seqno="7" type="S" level="2" pack="0" scale="0" length="25"
 pointer="0" inum="0" ufocc="0" />
<FLD name="U_DTYP" seqno="8" type="S" level="2" pack="0" scale="0" length="2"
 pointer="0" inum="0" ufocc="0" />
<FLD name="U_LAYOUT" seqno="9" type="S" level="2" pack="0" scale="0" length="46"
 pointer="0" inum="0" ufocc="0" />
<FLD name="U_DOC" seqno="10" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\C1,0,0,0,,0,0,0,," />
<FLD name="USCOPE" seqno="11" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\C2,0,0,0,,0,0,0,," />
<FLD name="UHINTERFACE" seqno="12" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\C3,0,0,0,,0,0,0,," />
</DSC>
<OCC>
<DAT name="UTIMESTAMP">2015-07-27T10:14:43.00</DAT>
<DAT name="U_FORMLIB">DROPBOX_SVC</DAT>
<DAT name="U_NAME">API_AUTHORISE_URL</DAT>
<DAT name="U_DTYP">S</DAT>
</OCC>
<OCC>
<DAT name="UTIMESTAMP">2015-07-24T15:56:34.00</DAT>
<DAT name="U_FORMLIB">DROPBOX_SVC</DAT>
<DAT name="U_NAME">API_CONTENT_URL</DAT>
<DAT name="U_DTYP">S</DAT>
</OCC>
<OCC>
<DAT name="UTIMESTAMP">2015-07-24T15:56:34.00</DAT>
<DAT name="U_FORMLIB">DROPBOX_SVC</DAT>
<DAT name="U_NAME">API_URL</DAT>
<DAT name="U_DTYP">S</DAT>
</OCC>
<OCC>
<DAT name="UTIMESTAMP">2015-08-03T13:54:37.00</DAT>
<DAT name="U_FORMLIB">DROPBOX_SVC</DAT>
<DAT name="U_NAME">LOCALE</DAT>
<DAT name="U_DTYP">S</DAT>
</OCC>
<OCC>
<DAT name="UTIMESTAMP">2015-07-24T15:56:34.00</DAT>
<DAT name="U_FORMLIB">DROPBOX_SVC</DAT>
<DAT name="U_NAME">TOKEN</DAT>
<DAT name="U_DTYP">S</DAT>
</OCC>
<OCC>
<DAT name="UTIMESTAMP">2015-07-24T15:56:34.00</DAT>
<DAT name="U_FORMLIB">DROPBOX_SVC</DAT>
<DAT name="U_NAME">UHTTP</DAT>
<DAT name="U_DTYP">H</DAT>
<DAT name="USCOPE">PUB</DAT>
</OCC>
<OCC>
<DAT name="UTIMESTAMP">2015-07-24T15:56:34.00</DAT>
<DAT name="U_FORMLIB">DROPBOX_SVC</DAT>
<DAT name="U_NAME">USER_AGENT</DAT>
<DAT name="U_DTYP">S</DAT>
</OCC>
</TABLE>
</UNIFACE>
